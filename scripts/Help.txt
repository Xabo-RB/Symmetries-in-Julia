Exactamente, en el contexto del código original que proporcionaste, las dos líneas son necesarias y no redundantes. La primera línea evalúa una cadena que contiene una expresión para crear una variable simbólica, y la segunda línea recupera la instancia de esa variable simbólica recién creada para su uso posterior.

Aquí te muestro el fragmento de código original nuevamente con una explicación paso a paso:

@variables t: define t como una variable simbólica global.
states = ["x1", "x2", "x3", "x4"]: crea una lista de nombres de estado que se utilizarán para generar variables simbólicas.
st = Num[]: inicializa un arreglo vacío de tipo Num para almacenar las variables simbólicas que se crean en el bucle.
Dentro del bucle for q in states:
Se construye una cadena con la declaración de la variable simbólica correspondiente a cada nombre de estado en states utilizando metaprogramación.
eval(Meta.parse(str)): evalúa la cadena para crear la variable simbólica. En este punto, la variable simbólica con el nombre en q se ha creado y está disponible para su uso.
var = eval(Meta.parse("$(q)(t)")): recupera la variable simbólica que acabamos de definir para que pueda ser manipulada en el código de Julia como un objeto de tipo Num. Aunque la creación y la recuperación podrían fusionarse en una operación, la separación en dos pasos permite una mayor claridad y control, especialmente en metaprogramación, donde las etapas de parseo y evaluación son críticas.
push!(st, var): agrega la variable simbólica al arreglo st.
La confusión podría surgir porque normalmente se espera que después de definir una variable simbólica con una macro, se pueda usar directamente. Sin embargo, debido a la manera en que se usa eval para interpretar las cadenas, necesitas recuperar la variable en un paso separado para poder usarla efectivamente.

Por lo tanto, para tu requerimiento original de crear variables en mayúsculas, seguirías un proceso similar, asegurándote de que después de usar eval para crear la variable simbólica en mayúsculas, recuperas esa instancia para su uso posterior. El código que proporcioné anteriormente sigue siendo relevante y válido para este propósito.